# 排班验证

<cite>
**Referenced Files in This Document**  
- [SchedulingService.cs](file://Services/SchedulingService.cs)
- [ConstraintValidator.cs](file://SchedulingEngine/Core/ConstraintValidator.cs)
</cite>

## 目录
1. [排班验证机制概述](#排班验证机制概述)
2. [请求验证逻辑](#请求验证逻辑)
3. [确认验证逻辑](#确认验证逻辑)
4. [关键未分配时段检测](#关键未分配时段检测)
5. [人员过度工作检测](#人员过度工作检测)
6. [验证失败场景与错误示例](#验证失败场景与错误示例)

## 排班验证机制概述

排班验证机制分为两个层面：请求验证和确认验证。请求验证在排班请求提交时执行，确保输入数据的业务合理性；确认验证在排班结果提交确认前执行，确保排班方案的完整性与公平性。该机制通过 `SchedulingService` 类中的 `ValidateSchedulingRequestBusinessLogicAsync` 和 `ValidateScheduleForConfirmationAsync` 方法实现，分别对应排班请求的业务规则验证和排班结果的确认前检查。

**Section sources**
- [SchedulingService.cs](file://Services/SchedulingService.cs#L19-L750)

## 请求验证逻辑

`ValidateSchedulingRequestBusinessLogicAsync` 方法在排班请求提交时执行，对请求参数进行多维度业务规则验证，确保排班任务的可行性。

### 人员可用性验证
该方法首先验证请求中指定的人员ID是否真实存在且处于可用状态。通过调用 `_personalRepo.GetPersonnelByIdsAsync` 获取人员列表，检查是否存在ID不匹配的情况。同时，筛选出 `IsAvailable` 为 `false` 或 `IsRetired` 为 `true` 的人员，若存在此类人员，则抛出包含具体姓名的异常。

### 哨位存在性验证
类似地，方法验证请求中指定的哨位ID是否真实存在。通过调用 `_positionRepo.GetPositionsByIdsAsync` 获取哨位列表，检查是否存在ID不匹配的情况，若存在则抛出异常。

### 技能匹配度验证
该方法调用私有方法 `ValidateSkillCompatibilityAsync` 来验证人员与哨位的技能匹配度。对于每个有技能要求的哨位，检查是否存在至少一名具备所有必需技能的人员。若某个哨位没有任何人员能够胜任，则抛出包含哨位名称的异常。

### 人员-哨位比例合理性验证
该方法通过 `ValidatePersonnelPositionRatio` 验证人员数量与哨位数量的比例是否合理。计算总需求班次数（哨位数 × 天数 × 12个时段）和理论最大可提供班次数（人员数 × 天数 × 8个时段）。若需求超过供给，则抛出“人员数量不足”的异常。此外，若人员利用率超过80%，会记录警告日志，提示排班可能困难。

**Section sources**
- [SchedulingService.cs](file://Services/SchedulingService.cs#L400-L450)

## 确认验证逻辑

`ValidateScheduleForConfirmationAsync` 方法在用户尝试确认排班结果前执行，对排班方案进行最终的完整性与公平性检查。

该方法首先调用 `GetCriticalUnassignedSlotsAsync` 检查是否存在关键的未分配时段，若存在则抛出异常。随后，调用 `GetOverworkedPersonnelAsync` 检查是否有人员工作量过重，若存在则抛出异常。只有当这两个检查都通过时，排班结果才能被确认。

此验证是排班流程中的最后一道防线，确保提交的排班方案既满足基本的覆盖要求，又符合人员工作量的公平性原则。

**Section sources**
- [SchedulingService.cs](file://Services/SchedulingService.cs#L535-L540)

## 关键未分配时段检测

`GetCriticalUnassignedSlotsAsync` 方法负责识别排班方案中必须分配的关键时段。

### 实现逻辑
该方法遍历排班周期内的每一天和每一个2小时时段（共12个），检查每个哨位在该时段是否已分配人员。它通过将排班结果映射为 `(日期, 时段, 哨位ID)` 的哈希集合来高效判断分配状态。

### 休息日夜间时段特殊处理
该方法的特殊之处在于对休息日夜间时段的处理。它首先通过 `_constraintRepo.GetActiveHolidayConfigAsync` 获取当前生效的休息日配置，并判断当前日期是否为休息日。对于夜间时段（定义为时段索引11、0、1、2，对应22:00-06:00），如果当天是休息日，则允许该时段不分配人员。这一规则体现了业务灵活性，避免了在非工作日强制安排夜间值班。

该方法返回所有未分配的关键时段列表，供 `ValidateScheduleForConfirmationAsync` 判断是否允许确认。

**Section sources**
- [SchedulingService.cs](file://Services/SchedulingService.cs#L500-L535)

## 人员过度工作检测

`GetOverworkedPersonnelAsync` 方法负责识别排班方案中工作量过重的人员。

### 实现逻辑
该方法首先通过 `GroupBy` 将排班结果按 `PersonnelId` 分组，统计每个人员的班次总数。然后，通过 `_personalRepo.GetPersonnelByIdsAsync` 获取人员信息以获取姓名。

### 每日4班次工作量限制
该方法定义了每日最多4个班次（即8小时）为“合理”的工作量上限。最大合理班次总数计算为 `daySpan * 4`。任何超过此上限的人员都被视为“过度工作”。

该方法返回所有过度工作人员的姓名和班次总数列表，供 `ValidateScheduleForConfirmationAsync` 判断是否允许确认。

**Section sources**
- [SchedulingService.cs](file://Services/SchedulingService.cs#L540-L564)

## 验证失败场景与错误示例

以下是排班验证失败的典型场景及其对应的错误消息示例。

### 请求验证失败场景
- **人员不存在或不可用**：错误消息示例：“以下人员ID不存在: 1001, 1002” 或 “以下人员当前不可用: 张三, 李四”。
- **哨位不存在**：错误消息示例：“以下哨位ID不存在: 2001, 2002”。
- **技能不匹配**：错误消息示例：“以下哨位没有合适的人员能够胜任: 东门岗, 监控室”。
- **人员数量不足**：错误消息示例：“人员数量不足：需要 720 个班次，但最多只能提供 560 个班次”。

### 确认验证失败场景
- **存在未分配的关键时段**：错误消息示例：“存在未分配的关键时段: 05-01 22:00-00:00, 05-02 00:00-02:00, 05-02 02:00-04:00 等共3个时段”。注意，休息日的22:00-06:00时段不会触发此错误。
- **人员工作量过重**：错误消息示例：“以下人员工作量过重: 王五(15班次), 赵六(14班次)”。

这些清晰的错误信息有助于用户快速定位问题并进行修正。

**Section sources**
- [SchedulingService.cs](file://Services/SchedulingService.cs#L535-L564)